MEWOutlineController = new Class({
  
    initialize: function(outlineElement, adjustColumnWidths, selectionChangedAction){

		// This is a method generated by WBLAjaxActionFunction
		this.selectionChangedAction = selectionChangedAction;

        // Create a keyboard. It is not active by default and will be activated after the user has clicked inside the outline view.
        this.createKeyboard();
        
        this.classOfSelectedRows = 'selected';
        
        // Add us to the autorelease pool
        PWAutoreleasePool.addObjectToPoolForElement(this, outlineElement);
        
        outlineElement.outlineComponent = this;
        this.outlineElement = outlineElement;
        this.initializeInvariants();

        // The element used to measure widths can be inside an iFrame. Because iFrames are loaded asynchronosly,
        // We have to wait until it is loaded.
        var me=this;
        GetLayoutIndependentMeasurementElement(function(measurementElement){
            me._measurementElement = measurementElement;
            
            if(adjustColumnWidths)
                me.adjustColumnWidths();

            // Text in elements with a data-hide-long-text attribute is made invisible if the cell contains an image and its size is below 50px.
            me.updateCellsWithLongText();

            // Detect the scroll element and add an observer to update autoformatted cells on scroll.
            me.updateScrollElementObserver();

            me.outlineElement.controller.updateLayout();

            function afterRowsAreValid(){
                // Cache autoformatted cells for later use.
                // Will be changed later when the outline becomes more dynamic.
                me.updateAutoformattedCellsCache();

                // Initially update the content of autoformated cells:
                me.replaceContentInVisibleCellsIfNeeded(false);
            }

            // Wait until the outline is rendered one time in order to get correct row position.
            afterRowsAreValid.delay(0, this);

            me.makeTableColumnsResizable();
            me.makeTableRowsSelectable();
                                               
            // Detect clicks inside the outline view and set the first responder
            me.updateClickObserver();
        });
    },
    
    updateClickObserver: function(){
		var clickElement = this.iFrame ? this.iFrame.contentDocument.defaultView : this.scrollElement;
    	var me = this;
		clickElement.addEvent('click', function(event){
      		me.clickedInsideOutline(event);
       	});
    },
    
	clickedInsideOutline: function(event){
		 //console.log('clicked inside outline'); // TODO: Set first responder
	},

    dispose: function() {        
        //console.log('dispose MEWOutlineController');
        this.iFrame = this.outlineElement.getElement('iframe');
        if(this.iFrame){
            if(this.iFrame.contentDocument)
                this.iFrame.contentDocument.defaultView.removeEvents('scroll');
        }else
            this.scrollElement.removeEvents('scroll');
        
        this.disposeKeyboard();
    },
    
    // Creates this.iFrame, this.scrollElement and this.table. Takes into account iFrames.    
    initializeInvariants: function(){
        this.iFrame = this.outlineElement.getElement('iframe');
        if(this.iFrame){
            var iFrameBody = this.iFrame.contentDocument.body;
            this.table = iFrameBody.getElement('table');
            this.tableWindow = this.iFrame.contentWindow; 
            this.scrollElement = PWIEVersion()>0 ? this.iFrame.contentDocument.body.parentElement : this.iFrame.contentDocument.body;
            this.scrollEventSource = this.iFrame.contentDocument.defaultView;

            // At this point we need to make sure we have a valid layout. So we need to remove the nolayout optimization
            iFrameBody.getElements('.nolayout').each(function(element){
                element.removeClass('nolayout');
            });
        }else{
            var tables = this.outlineElement.getElements('table');
            this.table = tables[1]; // 1 because of the header which is also a table
            // For debugging purposes only we fallback to the first table if no other is found
            if(!this.table)
                this.table = tables[0];
            
            this.tableWindow = window;
            this.scrollElement = this.table.getParent();
            this.scrollEventSource = this.scrollElement;
        }
        this.headerTable = this.outlineElement.getElement('.header');
        this.columns = this.table.getElements('col');
    },
      
    windowKeyboard: function(){
        if (!window.keyboard) {
            window.keyboard = new Keyboard();
            window.keyboard.activate();
        }
        return window.keyboard;
    },
    
    createKeyboard: function(){
        var keyboard = new Keyboard();
        this.windowKeyboard().manage(keyboard);
        var me = this;
        keyboard.addEvents({
            'up':function(e){me.upKeyPressed(e);},
            'shift+up':function(e){me.upKeyPressed(e);},
            'down':function(e){me.downKeyPressed(e);},
            'shift+down':function(e){me.downKeyPressed(e);}
        });
        this.keyboard = keyboard;
    },
    
    disposeKeyboard: function(){
        var keyboard = this.keyboard;
        keyboard.relinquish(); 
        keyboard.deactivate();
        window.keyboard.drop(keyboard);
    },
    
    upKeyPressed: function(event){
        this.selectPreviousRow(event);
    },
        
    downKeyPressed: function(event){
        this.selectNextRow(event);
    },        
        
    makeTableColumnsResizable: function(){
        
        var handles = this.headerTable.getElements('.handle');
        var contentColumns = this.table.getElements('col');
        var me = this;
        this.headerTable.getElements('col').each(function(col, index){
            var contentCol = contentColumns[index];
            col.makeResizable({handle:handles[index], 
                                limit:{x:[30,400]},
                               onDrag: function(el){
                                   me.onColumnResize(el, col, contentCol, index);
                                },
                               onStart: function(el){
                                   me.onColumnResizeStart(el, col, contentCol, index);
                               },
                               onComplete: function(el){
                                   me.onColumnResizeComplete(el, col, contentCol, index);
                               }});
        }, this);
        
    },
    
    onColumnResizeStart: function(el, headerColumn, contentColumn, index){
        $$('.iFrameShield').each(function(shield){
            shield.setStyle('display','block');
        });                                    
    },
    
    onColumnResize: function(el, headerColumn, contentColumn, index){
        
    },
    
    onColumnResizeComplete: function(el, headerColumn, contentColumn, index){
        contentColumn.setStyle('width', el.getStyle('width'));
        this.refreshAutoformattedCellsInColumn(contentColumn);
        this.updateCellsWithLongText();
        
        $$('.iFrameShield').each(function(shield){
            shield.setStyle('display','none');
        }); 
    },
    
    // Text in elements with a data-hide-long-text attribute is made invisible if the cell contains an image and its size is below 50px. 
    updateCellsWithLongText: function(){
        var spans = this.table.getElements('[data-hide-long-text]');	    
        spans.each(function(span){
            var parent = span.getParent();
            var cell = parent.getParent();
            var img = cell.getElement('img');
            if(img){
                var origDisplayStyle = span.origDisplayStyle;
                if(!origDisplayStyle){
                    origDisplayStyle = span.getStyle('display');
                    span.origDisplayStyle = origDisplayStyle;
                }
                var col = this.columnForCell(cell);
                var width = this.availableTextWidthInCell(cell, parent);
                var isToSmall = width < 55;
                span.setStyle('display', isToSmall ? 'none' : origDisplayStyle);
                //parent.setStyle('text-align', isToSmall ? 'center' : null);
                img.setStyle('position', isToSmall ? 'relative' : null);
                img.setStyle('left', isToSmall ? '50%' : null);
                img.setStyle('transform', isToSmall ? 'translateX(-50%)' : null);
                img.setStyle('-webkit-transform', isToSmall ? 'translateX(-50%)' : null);
            }
        }, this);
    },
    
    columnForCell: function(cell){
        return this.columns[cell.getProperty('idx').toInt()];
    },
    
    // Detect the scroll element and update autoformatted cells on scroll.
    updateScrollElementObserver: function() {
        var me = this;
        this.iFrame = this.outlineElement.getElement('iframe');
        if(this.iFrame)
            this.iFrame.contentDocument.defaultView.addEvent('scroll', function(){
                 me.replaceContentInVisibleCellsIfNeeded(true);
            });
        else
            this.scrollElement.addEvent('scroll', function(){
                 me.replaceContentInVisibleCellsIfNeeded(true);
            });
    },
    
    // updates this.rowsWithAutoformattedCells
    updateAutoformattedCellsCache: function() {
	   	var spans = this.table.getElements('[data-all-formatted-values]');	    
        this.rowsWithAutoformattedCells = spans.map(function(span){
			
			// Cache the autoformatted cells in the row
			var row = span.getParent('tr');
			if(!row.autoformatted)
				row.autoformatted = new Array();
			row.autoformatted.push(span);
			
			return row;
		}).unique();
		
        // Interval tree:
		var scrollTop = this.scrollElement.scrollTop;
        this.itree = new IntervalTree(this.table.getSize().y/2); // the center of the tree
		this.rowsWithAutoformattedCells.each(function(row){
            var rect = row.getBoundingClientRect();
            this.itree.add([rect.top+scrollTop, rect.bottom+scrollTop,  row]);	
        }, this);
		// // search 1: get overlapped regions from one point
		// var results = itree.search(103);
		// 
		// results.forEach(function(result) {
		//   console.log(result.data); // overlapped range data
		//   console.log(result.id);   // id of the overlapped range
		// });        
    },
        
    getVisibleAutoformattedCells: function() {
 
        if(this.rowsWithAutoformattedCells.length == 0)
        		return [];
        
        this.outlineTop = this.scrollElement.scrollTop;
        
        if(!this.iFrame)
        		this.outlineTop += this.scrollElement.getBoundingClientRect().top;
        this.outlineBottom = this.outlineTop + this.scrollElement.getSize().y;        

		// Use the interval tree:
		var rows = Array.from(this.itree.search(this.outlineTop,this.outlineBottom)).map(function(result){
			return result.data[2];
		}, this);
        
		// Simply touch each row:
		// var html = this.tableWindow.document.documentElement;
		// innerHeight = (this.tableWindow.innerHeight || html.clientHeight);		
		// var rows = this.rowsWithAutoformattedCells.filter(function(element){
		// 	var rect = element.getBoundingClientRect();
		// 	return rect.top >= 0 && rect.bottom <= innerHeight;
		// }, this);
		
		// Find the cells inside the rows
		var cells = new Array();
		rows.each(function(row){
			row.autoformatted.each(function(span){
				cells.push(span.getParent('td'));
			}, this);
		}, this);
		return cells;
    },

    getAutoformattedCellsInColumn: function(column){
        var index = column.getProperty('idx').toInt();
        var tds = this.table.getElements('td:nth-child('+(index+1)+')');
        return tds.filter(function(td){
            return td.getElement('[data-all-formatted-values]');
        });
    },
    
    refreshAutoformattedCellsInColumn: function(column){
        // We need to update the cache in any case, because the row height could have changed.
        // So our interval tree to detect the visible cells with auto format is no longer valid.
        
        this.clearCellWidthByIndex();
        
        // TODO: Do this only if row heights have really changed.
        this.updateAutoformattedCellsCache();
        var cells = this.getAutoformattedCellsInColumn(column);
        if(cells && cells.length > 0){        
            cells.each(function(cell){
                cell.hasValidContent = false;
            });            
            this.replaceContentInVisibleCellsIfNeeded(true);
        }
        
    },
    
    replaceContentInVisibleCellsIfNeeded: function(delay)
    {    
	    var cells = this.getVisibleAutoformattedCells();
        this.replaceContentInCellsIfNeeded(cells, delay);
    },

    replaceContentInCellsIfNeeded: function(cellElements, delay)
    {     
        // TEST
        delay = false;
        
        this.currentCellNumber = 0;
        cellElements.each(function(cellElement){
            if(!cellElement.hasValidContent){
                    this.currentCellNumber++;
                    // Set to delay if you want to enable fading.
                    var fade = false//delay;
            		cellElement.hasValidContent = true;
            		if(delay)
            			this.replaceContentInCellIfNeeded.delay(0, this, [cellElement, fade]);
            		else
            			this.replaceContentInCellIfNeeded(cellElement, fade);
            	}
        }, this);            
    },

	// Debugging only
	logRowOfCell: function(cellElement){
		var row = cellElement.getParent('tr').getElement('td > div > span').innerHTML;                    
		console.log('cell is visible ('+row.trim()+')');
	},

    clearCellWidthByIndex: function(){
        if(this.cellWidthByIndex)
            this.cellWidthByIndex.empty();
    },
    
    // cellElement must be a td element. element is the element we get the width from.
    // This method gets the width from a cache (this.cellWidthByIndex). 
    // If a width is not found it is measured and put into the cache.
    availableTextWidthInCell: function(cellElement, element){
        var idx = cellElement.getProperty('idx');
        var index = idx.toInt();
        var widths = this.cellWidthByIndex;
        if(!widths){
            widths = new Array();
            this.cellWidthByIndex = widths;
        }
        var cellWidth = widths[index];
        if(!cellWidth){
            cellWidth = element.offsetWidth;
            widths[index] = cellWidth;
            //console.log('index='+index+' width='+cellWidth);
        }
        return cellWidth;
    },
    
    // If more than one content representation is available for the cell, take the one which fits best into the width of the column.
    // cellElement must be a td element.
    replaceContentInCellIfNeeded: function(cellElement, fade){
        
        if(fade)
            cellElement.setStyle('opacity','0');
        
        var valueContainer     = cellElement.getElement('[data-all-formatted-values]'); // A span
        var allValues          = eval(valueContainer.getProperty('data-all-formatted-values'));
        var parent             = valueContainer.getParent();            
        var parentWidth        = this.availableTextWidthInCell(cellElement, parent);

        // ~ 2.5 Sekunden
        // var count = allValues.length;
        // for(var i=0; i<count; i++){
        //     valueContainer.innerHTML = allValues[i];
        //     if(valueContainer.getSize().x <= parentWidth)
        //         break;
        // }

        // ~ 2 Sekunden
        var styles = window.getComputedStyle(valueContainer);

        //AK
        valueContainer.innerHTML = this.bestFittingTextWithStyleInWidth(allValues, styles, parentWidth);                

        // ~ 3.1 Sekunden
        // var count = allValues.length;                
        // var text = '';
        // for(var i=0; i<count; i++){
        //     text = allValues[i];
        //     if(valueContainer.measureSizeWithInnerHTML(text) <= parentWidth)
        //         break;
        // }
        // valueContainer.innerHTML = text;

        // Remove the row from this.rowsWithAutoformattedCells if all cells have valid content:
        var row = cellElement.getParent('tr');
        row.autoformatted.erase(valueContainer);
        if(row.autoformatted.length == 0)
            this.rowsWithAutoformattedCells.erase(row);
        
        if(fade)
            cellElement.fade('in');
    },

    // Returns the text which fits best 
    bestFittingTextWithStyleInWidth: function(textArray, styles, width) {        
        
        var elem = this._measurementElement;
        elem.setStyles(styles)
        elem.setStyle('white-space', 'nowrap');
        var text = '';
        var count = textArray.length;                
         for(var i=0; i<count; i++){
             text = textArray[i];
             elem.innerHTML = text;
             if(elem.offsetWidth <= width)
                 break;
         }

        return text;
    },
    
    // For all columns without a width, the typical value string is used to determine a width.
    // The computed width is then applied to the header col and outline table col elements.
    adjustColumnWidths: function(){
		var allHeaderCols = this.outlineElement.getElements('.header col');
		allHeaderCols.each(function(headerCol, index){
			if(!headerCol.style['width'].toInt()){
				var identifier  = headerCol.getProperty('data-identifier');
				var outlineCol  = this.table.getElement('col[data-identifier='+identifier+']')
				var outlineCell = this.table.getElement('tr:first-child td:nth-child('+(index+1)+')');
                var headerCell  = this.outlineElement.getElement('tr:first-child td:nth-child('+(index+1)+')');
                				
                var width = this.proposedColumnWidth(outlineCol, outlineCell, headerCell);
                var widthInPixel = ''+width+'px';
				headerCol.setStyle('width', widthInPixel);
				outlineCol.setStyle('width', widthInPixel);
            }
		}, this);
    },
    
    // The width is computed by taking into account the header text and the typical value text.
    proposedColumnWidth: function(outlineColumn, outlineCell, headerCell){
        
        // Get the element used to measure the content width:
        var testElem = this._measurementElement;

        // Compute the minimum width:
        testElem.setStyles(this.importantCellStylesFromCell(headerCell));
        testElem.innerHTML = headerCell.innerHTML;
        var minWidth = testElem.getSize().x+10;
        
        // Use the style and the inner structure of the related outline cell from the first row:
        testElem.setStyles(this.importantCellStylesFromCell(outlineCell));

        var childs = outlineCell.getChildren().map(function(child){
            return child.clone();
        }, this);

        var typicalValue = outlineColumn.getProperty('data-typical-value');
        var innerSpan = null;

        if(childs){ 
            var spans = childs.filter(function(elem){
                return elem.get('tag') == 'span';
            });
            if(spans.length > 0)
                innerSpan = spans[0];
        };
        if(innerSpan){
            innerSpan.innerHTML = typicalValue;
            childs.each(function(child){
                child.inject(testElem);
            }, this);
        }
        else
            testElem.innerHTML = typicalValue;

        var nonTextWidthString = outlineColumn.getProperty('data-non-text-width');
        var nonTextWidth = nonTextWidthString ? parseFloat(nonTextWidthString) : 0;

        // Columns have a minimum width which fits the tiotle of the header.
        var size = testElem.getSize();
        var maxWidth = size.y * 6.0;
        var oneLineWidth = Math.max(size.x+nonTextWidth, minWidth);
        var result = Math.min(maxWidth, oneLineWidth);        
        
        // Columns have a min width:
        if(result < 50)
            result = 50;
        return result;
    },
    
    importantCellStylesFromCell: function(cell){
        var allStyles = window.getComputedStyle(cell);
        // We always need to set all styles
        /*
        var styles = {'font':allStyles['font']};
        var padding = allStyles['padding'];
        if(padding)
            styles['padding'] = padding;
        var paddingLeft = allStyles['padding-left'];
        if(paddingLeft)
            styles['padding-left'] = paddingLeft;
        var paddingRight = allStyles['padding-right'];
        if(paddingRight)
            styles['padding-right'] = paddingRight;
        */
        return allStyles;
    },
    
    rows: function(){
        return this.table.getElements('.row');
    },
    
    clearRowSelection: function(){
        var selectedRows = Array.clone(this.selectedRows);
        selectedRows.each(function(row, index){
            this.removeSelectionStyleFromRow(row, index);
        }, this);
    },
    
    computeAnchorIndexFromSelection: function(){        
//        this.setAnchorIndex(null);
//        this.rows().each(function(row, index){
//            if(row.hasClass(this.classOfSelectedRows)){
//                this.setAnchorIndex(index); 
//                return;
//            }
//        }, this);

		var indices = this.selectedRowInidices;
        this.setAnchorIndex(indices.length > 0 ? indices.getLast() : 0);
    },
    
    setAnchorIndex: function(index){
        if(index<0)
            index=0;
        else
        {
            var rowsCount = this.rows().length;
            if(index>=rowsCount)
                index=rowsCount-1;
        }
        this.anchorIndex = index;
    },
    
    selectSingleRow: function(row, index){
        this.clearRowSelection();
        this.addSelectionStyleToRow(row, index);
        this.setAnchorIndex(index);        
    },
    
    selectUpToRow: function(row, index, withKeyboard){
        if(this.anchorIndex == null){
            this.addSelectionStyleToRow(row, index);
            this.setAnchorIndex(index);
        }else {
            if(!withKeyboard)                
                this.clearRowSelection();
            var minIndex = Math.min(this.anchorIndex, index);
            var maxIndex = Math.max(this.anchorIndex, index);
            var rows = this.rows();
            for(var i=minIndex; i<=maxIndex; i++)
            {
                this.addSelectionStyleToRow(rows[i], index);
            }
        }        
    },
    
    toggleSelectionOfRow: function(row, index){
        var selClass = this.classOfSelectedRows;
        if(row.hasClass(selClass)){
            this.removeSelectionStyleFromRow(row, index);
            this.computeAnchorIndexFromSelection();
        }else{
            this.addSelectionStyleToRow(row, index);
            this.setAnchorIndex(index);
        }    
    },
    
    selectedClassProperty: 'data-selected-class',
    notSelectedClassProperty: 'data-not-selected-class',
    
    addSelectionStyleToRow: function(row, index){
        if(!this.selectedRows.contains(row))
            this.selectedRows.push(row);
        
        // Replace the content of the 'class' property  by the content of the 'data-selected-class' property if available.
        // (on the row and any element below with this property).
        var rowSelectedClass = row.getProperty(this.selectedClassProperty);
        var childElements = row.getElements('['+this.selectedClassProperty+']');
        var changed = false;
        if(rowSelectedClass){
            if(this.applySelectionStyleToElement(row))
                changed = true;
        }
        childElements.each(function(element){
            if(this.applySelectionStyleToElement(element))
                changed = true;
        }, this);
        
        if(changed)
            this.selectionStyleDidChangeInRow(row, index);
        
        // Note: Serverseitig Rows berÃ¼cksichtigen, die schon selektiert sind    
        row.addClass(this.classOfSelectedRows);
    },

    removeSelectionStyleFromRow: function(row, index){
        this.selectedRows.erase(row);
        
        var rowSelectedClass = row.getProperty(this.selectedClassProperty);
        var childElements = row.getElements('['+this.selectedClassProperty+']');
        var changed = false;
        if(rowSelectedClass){
            if(this.applyNormalStyleToElement(row))
                changed = true;
        }
        childElements.each(function(element){
            if(this.applyNormalStyleToElement(element))
                changed = true;
        }, this);        

        if(changed)
            this.selectionStyleDidChangeInRow(row, index);

        row.removeClass(this.classOfSelectedRows);
    },

    selectionStyleDidChangeInRow: function(r, i){
        this.changedRows.push({row:r, index:i});
    },
    
    applySelectionStyleToElement: function(element){
        var origClass = element.getProperty('class');
        var selClass = element.getProperty(this.selectedClassProperty);
        if(!element.isNotSelectedClass)
            element.isNotSelectedClass = origClass;
        
        if(origClass != selClass){            
            element.setProperty('class', selClass);
            return true;
        }
        return false;
    },

    applyNormalStyleToElement: function(element){
        if(element.isNotSelectedClass){
            if(element.getProperty('class') != element.isNotSelectedClass){
                element.setProperty('class', element.isNotSelectedClass);
                return true;
            }
        }
        return false;
    },
    
    selectionEventInRow: function(row, index, event){
        this.changedRows = new Array();
        
        // Shift the keyboard focus to this outline view:
        var withKeyboard = event.type == 'keydown';        
        if(!withKeyboard) // Mouse events
            this.keyboard.activate();
        if(!event.meta && !event.shift)
            this.selectSingleRow(row, index);
        else if(event.meta)
            this.toggleSelectionOfRow(row, index);
        else if(event.shift)
            this.selectUpToRow(row, index, withKeyboard);
        this.updateSelectionBorders();
        
        this.selectionStyleDidChangeInRowsWithIndex(this.changedRows);
    },
    
	selectedRowInidices: function(){
		var indices = [];
		var count = this.selectedRows.length;
		for(var i=0; i<count; i++){
			var row = this.selectedRows[i];
			if(row.index)
				indices.push(row.index);
		}
		return indices;
	},

	// Can be overwritten in subclasses
    selectionStyleDidChangeInRowsWithIndex: function(rowsWithIndex){
	    
    	// TODO: We should call this only once a second or so:
		// console.log('Selection did change: '+this.selectedRows.length/2+' rows are selected');
		if(this.selectionChangedAction)
            this.selectionChangedAction({'indices':this.selectedRowInidices()});
    },
    
    addSelectionTopBorderToRows: function(rows, index){
        Array.each(rows, function(row){
            row.addClass('selectionTop');
        });
    },

    addSelectionBottomBorderToRows: function(rows, index){
        Array.each(rows, function(row){
            row.addClass('selectionBottom');
        });
    },
    
    removeSelectionTopBorderFromRows: function(rows, index){
        Array.each(rows, function(row){
            row.removeClass('selectionTop');
        });
    },
    
    removeSelectionBottomBorderFromRows: function(rows, index){
        Array.each(rows, function(row){
            row.removeClass('selectionBottom');
        });
    },

    updateSelectionBorders: function(){
        var selClass    = 'selected';
        var outlineRows = this.rows();
        var count       = outlineRows.length;
        var previousRow = null;
        var previousRowIsSelected = false;

        for(var i=0; i<count; i++)
        {
            var row = outlineRows[i];
            var isSelected = row.hasClass(selClass);
            if(!isSelected){
                this.removeSelectionTopBorderFromRows([row], i);
                this.removeSelectionBottomBorderFromRows([row], i);
            }
            if(!previousRowIsSelected && isSelected)
                this.addSelectionTopBorderToRows([row], i);
            else if(!isSelected && previousRowIsSelected)
                this.addSelectionBottomBorderToRows([previousRow], i-1);
            else if(isSelected && previousRowIsSelected) {
                this.removeSelectionBottomBorderFromRows([previousRow], i-1);
                this.removeSelectionTopBorderFromRows([row], i);
            }            
            
            if(isSelected && i == count-1){
                this.addSelectionBottomBorderToRows([row], i);
            }
            previousRowIsSelected = isSelected;
            previousRow = row;
        }        
    },
    
    makeTableRowsSelectable: function(){
        
        // TEST TEST
//        return;
        
        this.selectedRows = new Array();
        var selClass = this.classOfSelectedRows;
        this.prepareRowsWithServerSideSelection();
        this.updateSelectionBorders();
        var me = this;
        this.rows().each(function(row, index){
            row.index = index; // Used in computeAnchorIndexFromSelection()
            row.addEvent('mousedown', function(event){
                me.lastRowIndexSelectedWithShift = undefined;
                me.selectionEventInRow(row, index, event);
                event.stop();
            });
        });
        this.computeAnchorIndexFromSelection();
    },
    
    // Fills the normal css classes cache of elements with a server side selection.
    prepareRowsWithServerSideSelection: function(){
        var selectedClassProperty = this.selectedClassProperty;
        var notSelectedClassProperty = this.notSelectedClassProperty;
        this.table.getElements('['+notSelectedClassProperty+']').each(function(element){
           element.isNotSelectedClass = element.getProperty(notSelectedClassProperty);
           element.setProperty(selectedClassProperty, element.getProperty('class'));
        });
        
        // Initially fill the selected rows array:
        this.selectedRows = this.table.getElements('.row.selected');
    },
    
    selectPreviousRow: function(event){
        var rows = this.rows();
        var count = rows.length;
        if(!event.shift){
            if(this.lastRowIndexSelectedWithShift  != undefined)
                this.setAnchorIndex(this.lastRowIndexSelectedWithShift);
            this.lastRowIndexSelectedWithShift = undefined;
        }
        var anchorIndex = this.anchorIndex;
        if(anchorIndex == undefined)
            anchorIndex = count-1;
        var startIndex = this.lastRowIndexSelectedWithShift != undefined ? this.lastRowIndexSelectedWithShift : anchorIndex;
        var onlyUnselectedRows = false; // TODO
        var index = this.getPreviousSelectableRowIndex(startIndex, rows, onlyUnselectedRows);
        var row = rows[index];
        this.selectionEventInRow(row, index, event);
        if(event.shift)
            this.lastRowIndexSelectedWithShift = index;
        this.scrollRowIntoVisibleArea(row);
    },
    
    getPreviousSelectableRowIndex: function(startIndex, rows, onlyUnselectedRows){
        var index = startIndex;
        if(onlyUnselectedRows)
            while(true){
                if(!rows[index].hasClass('selected') || index==0)
                    break;
                index--;
            }
        else
            index = Math.max(startIndex-1, 0);
        return index;
    },
    
    selectNextRow:function(event){        
        var rows = this.rows();
        var count = rows.length;
        var onlyUnselectedRows;
        if(!event.shift){
            if(this.lastRowIndexSelectedWithShift != undefined){
                this.setAnchorIndex(this.lastRowIndexSelectedWithShift);
            }
            this.lastRowIndexSelectedWithShift = undefined;
        }
        var anchorIndex = this.anchorIndex;
        if(anchorIndex == undefined)
            anchorIndex = 0;
        var startIndex = this.lastRowIndexSelectedWithShift != undefined ? this.lastRowIndexSelectedWithShift : anchorIndex;
        var onlyUnselectedRows = false; // TODO
        var index = this.getNextSelectableRowIndex(startIndex, rows, onlyUnselectedRows);
        var row = rows[index];
        this.selectionEventInRow(row, index, event);
        if(event.shift)
            this.lastRowIndexSelectedWithShift = index;
        this.scrollRowIntoVisibleArea(row);
    },
    
    getNextSelectableRowIndex: function(startIndex, rows, onlyUnselectedRows){
        var endIndex = rows.length-1;
        var index = startIndex;
        if(onlyUnselectedRows)
            while(true){
                if(!rows[index].hasClass('selected') || index==endIndex)
                    break;
                index++;
            }
        else
            index = Math.min(startIndex+1, endIndex);
        return index;
    },
    
    scrollRowIntoVisibleArea: function(row){
        var scrollElement = this.outlineElement.controller.scrollElement();
        var oTop    = scrollElement.scrollTop;
        var oBottom = oTop + scrollElement.getSize().y;
        var rTop    = row.offsetTop;
        var rBottom = rTop + row.offsetHeight;
        
        if(    (rTop < oTop || rBottom > oBottom) 
           && !(rTop < oTop && rBottom > oBottom)) {
            if(rTop < oTop)
                scrollElement.scrollTop = rTop;
            else if (rBottom > oBottom)
                scrollElement.scrollTop = rBottom-(oBottom-oTop);
        }
    }
    
 });
